# -*- coding: utf-8 -*-
"""feature_extraction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aU49N7QNDTaWKPjAo0vGxVOKSTHB0aau
"""

import numpy as np
import librosa

def add_noise(data, random=False, rate=0.035, threshold=0.075):
    if random:
        rate = np.random.random() * threshold
    noise = rate * np.random.uniform() * np.amax(data)
    augmented_data = data + noise * np.random.normal(size=data.shape[0])
    return augmented_data

def shifting(data, rate=1000):
    augmented_data = int(np.random.uniform(low=-5, high=5) * rate)
    augmented_data = np.roll(data, augmented_data)
    return augmented_data

def pitching(data, sr, pitch_factor=0.7, random=False):
    if random:
        pitch_factor = np.random.random() * pitch_factor
    return librosa.effects.pitch_shift(y=data, sr=sr, n_steps=pitch_factor)

def stretching(data, rate=0.8):
    return librosa.effects.time_stretch(y=data, rate=rate)

def extract_features(data, sr, frame_length=2048, hop_length=512):
    result = np.array([])
    mfcc_feat = librosa.feature.mfcc(y=data, sr=sr, n_mfcc=13, hop_length=hop_length, n_fft=frame_length)
    for i in range(mfcc_feat.shape[0]):
        result = np.hstack((result,
                           np.mean(mfcc_feat[i]),
                           np.std(mfcc_feat[i]),
                           np.min(mfcc_feat[i]),
                           np.max(mfcc_feat[i])))
    return result

def get_features(path, duration=2.5, offset=0.6):
    data, sr = librosa.load(path, duration=duration, offset=offset)
    target_length = int(sr * duration)
    if len(data) < target_length:
        data = np.pad(data, (0, target_length - len(data)))
    elif len(data) > target_length:
        data = data[:target_length]

    aud = extract_features(data, sr)
    audio = np.array([aud])

    noised_audio = add_noise(data, random=True)
    aud2 = extract_features(noised_audio, sr)
    audio = np.vstack((audio, [aud2]))

    pitched_audio = pitching(data, sr, random=True)
    aud3 = extract_features(pitched_audio, sr)
    audio = np.vstack((audio, [aud3]))

    pitched_audio1 = pitching(data, sr, random=True)
    pitched_noised_audio = add_noise(pitched_audio1, random=True)
    aud4 = extract_features(pitched_noised_audio, sr)
    audio = np.vstack((audio, [aud4]))

    stretch_rate = 0.8 + np.random.random() * 0.4
    stretched_audio = stretching(data, rate=stretch_rate)
    if len(stretched_audio) < target_length:
        stretched_audio = np.pad(stretched_audio, (0, target_length - len(stretched_audio)))
    elif len(stretched_audio) > target_length:
        stretched_audio = stretched_audio[:target_length]
    aud5 = extract_features(stretched_audio, sr)
    audio = np.vstack((audio, [aud5]))

    stretched_audio2 = stretching(data, rate=stretch_rate)
    if len(stretched_audio2) < target_length:
        stretched_audio2 = np.pad(stretched_audio2, (0, target_length - len(stretched_audio2)))
    elif len(stretched_audio2) > target_length:
        stretched_audio2 = stretched_audio2[:target_length]
    stretched_noised_audio = add_noise(stretched_audio2, random=True)
    aud6 = extract_features(stretched_noised_audio, sr)
    audio = np.vstack((audio, [aud6]))

    return audio